<?php
namespace AppBundle\Entity;

/**
 * EventsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EventsRepository extends \Doctrine\ORM\EntityRepository {

    private $eventsList = [];
    private $url = 'https://pushall.ru/api.php';
    private $params = [
        'type' => 'unicast',
        'id' => '',
        'key' => '',
        'uid' => '',
        'title' => '',
        'text' => '',
        'url' => '',
    ];
    private $minDelay = "PT30M";  // задержка до повторной отправки сообщения

    public function setParams($id, $api_key, $url, $min_delay) {
        $this->params['id'] = $id;
        $this->params['key'] = $api_key;
        $this->minDelay=  $min_delay;
        $this->params['url'] = $url;
    }

    /**
     * Функция  выбирает варианты событий для заданной комнаты, по которым не было оповещений за $minDelay
     * проверяет выходы параметров за пределы, отправляет уведомления,
     * @param type $s
     * @param type $room
     * @return type
     */
    public function checkEvents($s, $room) {
        $em = $this->getEntityManager();
        $n = new \DateTime("now", new \DateTimeZone("Europe/Moscow"));
        $ev_time = $n->sub(new \DateInterval($this->minDelay));
        $query = $em->createQuery("select e
            from AppBundle:Events e
            join e.room r
            join e.userid u
            where e.room = :room and
            e.id not in (
            select IDENTITY(h.ev) from AppBundle:Histories h where h.evTime >:ev_time)")
                ->setParameter('room', $room->getId())
                ->setParameter("ev_time", $ev_time);
        $ev = $query->getResult();
        $stat = $s[0];
        foreach ($ev as $e) {
            $this->checkT($e, $stat);
            $this->checkH($e, $stat);
            $this->checkCO2($e, $stat);
            $this->checkVOC($e, $stat);
        }
        return $this->sendEvents();
    }

    private function sendEvents() {
        $ret = '';
        foreach ($this->eventsList as $e) {
            $this->params['uid'] = $e['userid']->getUid();
            $this->params['title'] = $e['header'];
            $this->params['text'] = $e['body'];
            $this->addHistory($e['event']);
            $ret .= $this->send_post();

        }
        return $ret;
    }

    private function send_post() {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $this->url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $this->params);
        $output = curl_exec($ch);
        curl_close($ch);
        return $output;
    }

    private function checkT($e, $stat) {

    }

    private function checkH(\AppBundle\Entity\Events $e, $stat) {
        if ($e->getHmin() > 0 && $e->getTmax() < $stat['avg_t'] && $e->getHmin() > $stat['avg_h']) {
            $this->addEvent($e, $stat['avg_h']);
        }
    }

    private function checkVOC(\AppBundle\Entity\Events $e, $stat) {
        if ($e->getVocmax() > 0 && $e->getVocmax() < $stat['avg_voc']) {
            $this->addEvent($e, $stat['avg_voc']);
        }
    }

    private function checkCO2(\AppBundle\Entity\Events $e, $stat) {
        if ($e->getCo2max() > 0 && $e->getCo2max() < $stat['avg_co2']) {
            $this->addEvent($e, $stat['avg_co2']);
        }
    }

    private function addHistory(\AppBundle\Entity\Events $e) {
        $em = $this->getEntityManager();
        $his = $em->getRepository('AppBundle:Histories');
        $his->addHisEvent($e);
    }

    private function addEvent(\AppBundle\Entity\Events $e, $val) {
        $this->eventsList[] = [
            'id' => $e->getId(),
            'userid' => $e->getUserid(),
            'header' => $e->getDescription(),
            'body' => $e->getDescription() . " " . round($val, 2),
            'event'=>$e,
        ];
    }

}
