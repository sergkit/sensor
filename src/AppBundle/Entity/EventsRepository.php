<?php

namespace AppBundle\Entity;

/**
 * EventsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EventsRepository extends \Doctrine\ORM\EntityRepository {

    private $eventsList = [];
    private $url = 'https://pushall.ru/api.php';
    private $params = [
        'type' => 'unicast',
        'id' => '',
        'key' => '',
        'uid' => '',
        'title' => '',
        'text' => '',
        'url' => '',
    ];
    private $ev_time;
    private $minDelay = "PT30M";  // задержка до повторной отправки сообщения
    private $status = 0; // статус для зажигания светодиода на блоке 0нормально, 2 - включен, 8 - включить увлажнилку
    private $statusLed = 2; // бит для включения светодиода
    private $statusDeh = 8; // бит для включения увлажнителя
    private $statusVoc = 4; // бит для включения увлажнителя

    public function setParams($id, $api_key, $url, $min_delay) {
        $this->params['id'] = $id;
        $this->params['key'] = $api_key;
        $this->minDelay = $min_delay;
        $this->params['url'] = $url;
    }

    /**
     * Функция  выбирает варианты событий для заданной комнаты, по которым не было оповещений за $minDelay
     * проверяет выходы параметров за пределы, отправляет уведомления,
     * @param type $s
     * @param type $room
     * @return type
     */
    public function checkEvents($s, $room) {
        $em = $this->getEntityManager();
        $n = new \DateTime("now", new \DateTimeZone("Europe/Moscow"));
        $this->ev_time = $n->sub(new \DateInterval($this->minDelay));
        $qb = $em->createQueryBuilder();
        $qb->select('e', 'max(h.evTime)')
                ->from('AppBundle:Events', 'e')
                ->leftJoin('AppBundle:Histories', 'h', \Doctrine\ORM\Query\Expr\Join::WITH, 'h.ev=e.id')
                ->join('e.room', 'r')
                ->join("e.userid", "u")
                ->where("e.room = :room")
                ->groupBy('e.id')
                ->setParameter('room', $room->getId());
        $query = $qb->getQuery();
        $ev = $query->getResult();
        $stat = $s[0];
        foreach ($ev as $e) {
            $last = (isset($e[1]) ? new \DateTime($e[1], new \DateTimeZone("Europe/Moscow")) : new \DateTime("2012-07-08"));
            $this->checkT($e, $stat, $last);
            $this->checkH($e, $stat, $last);
            $this->checkCO2($e, $stat, $last);
            $this->checkVOC($e, $stat, $last);
        }
        return $this->sendEvents();
    }

    private function sendEvents() {
        $ret = '';
        foreach ($this->eventsList as $e) {
            $this->params['uid'] = $e['userid']->getUid();
            $this->params['title'] = $e['header'];
            $this->params['text'] = $e['body'];
            $this->addHistory($e['event']);
            $ret .= $this->send_post();
        }
        $ret.="##" . $this->status;
        return $ret;
    }

    private function send_post() {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $this->url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $this->params);
        $output = curl_exec($ch);
        curl_close($ch);
        return $output;
    }

    /**
     * функция для установки битов статусов
     * @param byte $status
     */
    private function setStatus($status) {
        if (($status & $this->status)!==0){
            $this->status+=$status;
        }
    }

    private function checkT($e, $stat, \DateTime $last) {
        
    }

    private function checkH($e, $stat, \DateTime $last) {
        //обработка уровня воды в увлажнилке
        if ($stat['deh'] > 0) {
             if ($this->ev_time > $last) {
               $this->addEvent($e[0]->setDescription("Нет воды в увлажнилке "), $stat['avg_h']);
            }
        }

        if ($e[0]->getHmin() > 0 && $e[0]->getTmax() < $stat['avg_t'] && $e[0]->getHmin() > $stat['avg_h']) {
            $this->setStatus($this->statusLed);
            $this->setStatus($this->statusDeh);
            if ($this->ev_time > $last) {
                $this->addEvent($e[0], $stat['avg_h']);
            }
        }
    }

    private function checkVOC($e, $stat, \DateTime $last) {
        if ($e[0]->getVocmax() > 0 && $e[0]->getVocmax() < $stat['avg_voc']) {
            $this->setStatus($this->statusLed);
            $this->setStatus($this->statusVoc);
            if ($this->ev_time > $last) {
                $this->addEvent($e[0], $stat['avg_voc']);
            }
        }
    }

    private function checkCO2($e, $stat, \DateTime $last) {
        if ($e[0]->getCo2max() > 0 && $e[0]->getCo2max() < $stat['avg_co2']) {
            $this->setStatus($this->statusLed);
            if ($this->ev_time > $last) {
                $this->addEvent($e[0], $stat['avg_co2']);
            }
        }
    }

    private function addHistory(\AppBundle\Entity\Events $e) {
        $em = $this->getEntityManager();
        $his = $em->getRepository('AppBundle:Histories');
        $his->addHisEvent($e);
    }

    private function addEvent(\AppBundle\Entity\Events $e, $val) {
        $this->eventsList[] = [
            'id' => $e->getId(),
            'userid' => $e->getUserid(),
            'header' => $e->getDescription(),
            'body' => $e->getDescription() . " " . round($val, 2),
            'event' => $e,
        ];
    }

}
